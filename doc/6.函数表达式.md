# 函数表达式
> 学习本章你将知道：函数表达式的特征；
> 使用函数实现递归；
> 使用闭包定义私有变量。
> 

函数表达式是JavaScript中一个既强大又容易令人困惑的特性。前面的章节已经介绍过，定义函数有2种方式：一种是函数声明，另一种是函数表达式。
函数声明的语法是这样的：
```javascript
function functionName(arg0,arg1,arg2){
    //函数体
}
```
关于函数声明，它有一个重要特征就是`函数声明提升`，意思是在执行代码之前会先读取函数声明。这意味着可以可以把函数声明放在调用它的语句后面。
```javascript
sayHi();
function sayHi(){
    alert("Hi");
}
```

第二种创建函数的方式是使用函数表达式。
```javascript
var functionName = function(arg0,arg1,arg2){
    //函数体
};
```
这种形式看起来好像是常规变量的赋值语句，即创建一个函数并将它赋值给变量functionName，这种情况下创建的函数叫匿名函数。函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误
```javascript
sayHi();//错误：函数不存在
var sayHi = function(){
    alert("Hi");
};
```
能够创建函数赋值给变量，也就能够把函数作为其他函数的值返回，还记得前面引用类型章节那个createComparisonFunction()函数吗：
```javascript
function createComparisonFunction(propertyName){
    return function(object1,object2){
        var value1 = object1[propertyName];
        var value2 = boject2[propertyName];
        if(value1<value2){
            return -1;
        }else if(value1>value2){
            return 1;
        }else{
            return 0;
        }
    };
}
```
createComparisonFunction()函数就返回了一个匿名函数。返回的函数可能会被赋值给一个变量，或者以其他方式被调用；不过在createComparisonFunction()内部，它是匿名的。把函数当成值来使用的情况下，都可以使用匿名函数。不过这并不是匿名函数的唯一用途。

## 一、递归
递归函数是在一个函数通过名字调用自身的情况下构成的。
```javascript
function factorial(num){
    if(num<=1){
        return 1;
    }else{
        return num*factorial(num-1);
    }
}
```
这是一个经典的递归函数阶乘。虽然这个函数表面上看没什么问题，但是下面的代码可能导致它出错。
```javascript
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4));//error，factorial已经不再是函数
```
使用arguments.callee可以解决这个问题。
```javascript
function factorial(num){
    if(num<=1){
        return 1;
    }else{
        return num*arguments.callee(num-1);//使用arguments.callee代替匿名函数
    }
}
```
使用arguments.callee可以确保怎样调用函数都不会出问题。但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过可以使用命名函数表达式来达成相同的结果。例如：
```javascript
var factorial = (function f(num){
    if(num<=1){
        return 1;
    }else{
        return num*f(num-1);
    }
});
```
以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给另一个变量，函数名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。

## 二、闭包












